# üîç MAPEO DETALLADO: M√âTODOS ‚Üí L√çNEAS DE C√ìDIGO

## Localizaci√≥n Exacta de Cada M√©todo en led_detector_final.py

### ‚úÖ a) CONVERSI√ìN A ESCALA DE GRISES

**L√≠nea 280-285**
```python
def _preprocess(self, frame: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    # Convertir a escala de grises si es necesario
    if len(frame.shape) == 3:
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)  # ‚Üê L√çNEA 283
    else:
        gray = frame.copy()
```

**Tambi√©n aparece en:**
- L√≠nea 407: `_detect_via_contours()` - Conversi√≥n de HSV a gris
- L√≠nea 427: `_detect_via_hough()` - Recibe gray como par√°metro
- L√≠nea 561: `_detect_via_contours()` - `gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)`

---

### ‚úÖ b) ESPACIO DE COLOR HSV

**L√≠nea 407-413**
```python
def _detect_via_contours(self, frame: np.ndarray):
    if len(frame.shape) == 2:
        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)  # ‚Üê L√çNEA 410
    
    lower = np.array([0, 0, 200])      # H ‚àà [0,180], S ‚àà [0,100], V > 200
    upper = np.array([180, 100, 255])  # Detecta p√≠xeles muy brillantes
    mask = cv2.inRange(hsv, lower, upper)  # ‚Üê L√çNEA 414
```

**Explicaci√≥n de rangos:**
- H: [0, 180] = Cualquier color (los LEDs IR no tienen color espec√≠fico)
- S: [0, 100] = Saturaci√≥n BAJA (LEDs son casi blancos cuando brillan)
- V: [200, 255] = Brillo MUY ALTO (LEDs infrarojos intensos)

**Uso posterior:**
- L√≠nea 415: Operaciones morfol√≥gicas sobre la m√°scara HSV
- L√≠nea 417: `cv2.findContours()` sobre m√°scara HSV

---

### ‚úÖ c) FILTRADO ESPACIAL (GAUSSIANO + MEDIANA)

**L√≠nea 287-301**
```python
def _preprocess(self, frame: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    # ... (conversi√≥n a gris)
    
    # GAUSSIANA: Suavizado progresivo
    blurred = cv2.GaussianBlur(gray, self.gaussian_kernel, 1.5)  # ‚Üê L√çNEA 294
    
    # MEDIANA: Filtro que preserva mejor los bordes que Gaussiana
    filtered = cv2.medianBlur(blurred, self.median_kernel)  # ‚Üê L√çNEA 300
    
    return gray, filtered
```

**Par√°metros inicializados en __init__:**
- L√≠nea 257: `self.gaussian_kernel = (5, 5)`
- L√≠nea 258: `self.median_kernel = 5`

**Orden de aplicaci√≥n:**
1. Gaussian (5√ó5, œÉ=1.5) ‚Üí Suaviza gradualmente
2. Median (5√ó5) ‚Üí Elimina p√≠xeles aislados, preserva bordes

---

### ‚úÖ d) UMBRALIZACI√ìN ADAPTATIVA

**L√≠nea 318-329**
```python
def _detect_via_adaptive_threshold(self, gray: np.ndarray):
    thresh = cv2.adaptiveThreshold(
        gray, 255,                                      # ‚Üê L√çNEA 319
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,                # L√çNEA 320
        cv2.THRESH_BINARY,                             # L√çNEA 321
        31,                                            # L√çNEA 322 - Tama√±o vecindario
        2                                              # L√çNEA 323 - Constante
    )
```

**Par√°metros:**
- M√©todo: GAUSSIAN_C = Umbral local (no global)
- Tama√±o: 31√ó31 = Vecindario bastante grande
- Constante: 2 = Margen de sensibilidad

**M√©todo completo:**
- L√≠nea 318-329: Conversi√≥n a m√°scara binaria
- L√≠nea 330-339: Extracci√≥n de blobs y c√°lculo de confianza

---

### ‚úÖ e) DETECCI√ìN DE BLOBS BRILLANTES

**L√≠nea 303-317**
```python
def _detect_via_high_threshold(self, gray: np.ndarray):
    # PASO 1: Umbralizar (valores > 200 = LED potencial)
    _, thresh = cv2.threshold(gray, 200, 255, cv2.THRESH_BINARY)  # ‚Üê L√çNEA 305
    
    # PASO 2: Operaci√≥n CIERRE morfol√≥gica
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=2)  # ‚Üê L√çNEA 310
    
    # PASO 3: Etiquetar componentes conexos (BLOB DETECTION)
    num_labels, _, stats, _ = cv2.connectedComponentsWithStats(
        thresh, connectivity=8  # ‚Üê L√çNEA 315
    )
    
    # PASO 4-5: Para cada blob, calcular centroide
    leds = []
    for i in range(1, num_labels):  # ‚Üê L√çNEA 320
        area = stats[i, cv2.CC_STAT_AREA]
        # ... filtrado por √°rea ...
```

**Flujo completo:**
- L√≠nea 305: Threshold simple (p√≠xeles > 200)
- L√≠nea 310: Cierre morfol√≥gica (rellena huecos)
- L√≠nea 315: Etiquetar componentes conexos
- L√≠nea 320-337: Bucle para extraer cada blob

---

### ‚úÖ f) DETECCI√ìN DE BORDES CANNY (IMPL√çCITA)

**NO hay llamada expl√≠cita a `cv2.Canny()`**

Sin embargo, se usa impl√≠citamente:
- L√≠nea 340: `cv2.HoughCircles(filtered, ...)` requiere imagen con bordes definidos
- L√≠nea 294-300: El filtrado Gaussiano + Mediana preserva bordes naturales

**Para mejorar, podr√≠as a√±adir (no est√° hecho):**
```python
def _detect_via_hough(self, gray, filtered):
    # Mejora propuesta (NO ACTUAL):
    edges = cv2.Canny(filtered, 50, 150)  # ‚Üê No est√° en el c√≥digo
    circles = cv2.HoughCircles(edges, ...)
    
    # Actual:
    circles = cv2.HoughCircles(filtered, ...)  # ‚Üê L√≠nea 340
```

---

### ‚úÖ g) TRANSFORMADA DE HOUGH (C√çRCULOS)

**L√≠nea 340-361**
```python
def _detect_via_hough(self, gray: np.ndarray, filtered: np.ndarray):
    circles = cv2.HoughCircles(
        filtered,                       # ‚Üê L√çNEA 341
        cv2.HOUGH_GRADIENT,            # M√©todo de Hough
        dp=1,                          # Resoluci√≥n 1:1
        minDist=40,                    # Distancia m√≠nima entre centros
        param1=150,                    # Umbral Canny superior
        param2=25,                     # Umbral acumulador
        minRadius=5,                   # Radio m√≠nimo esperado
        maxRadius=25                   # Radio m√°ximo esperado
    )
    
    leds = []
    if circles is not None:
        circles = np.uint16(np.around(circles))
        for i in circles[0, :]:        # ‚Üê L√çNEA 350 - Itera sobre c√≠rculos detectados
            x, y, r = float(i[0]), float(i[1]), float(i[2])
            # ...
```

**Calibraci√≥n para este video:**
- minRadius=5: LEDs peque√±os
- maxRadius=25: LEDs grandes
- minDist=40: Evita detectar mismo LED 2 veces
- param2=25: Sensibilidad del acumulador

---

### ‚úÖ i) CENTROIDE PONDERADO (MOMENTOS)

**Opci√≥n 1: Ajuste de Elipse (L√≠nea 393-396)**
```python
for contour in contours:
    area = cv2.contourArea(contour)
    
    if self.min_led_area < area < self.max_led_area:
        if len(contour) >= 5:
            ellipse = cv2.fitEllipse(contour)  # ‚Üê L√çNEA 394 - Ajuste de elipse
            x, y = ellipse[0]
```

**Opci√≥n 2: Momentos (Centroide Ponderado) - L√≠nea 396-401**
```python
        else:
            m = cv2.moments(contour)  # ‚Üê L√çNEA 397 - MOMENTOS
            if m["m00"] > 0:
                x = m["m10"] / m["m00"]  # ‚Üê L√çNEA 399 - Centro X (subp√≠xel)
                y = m["m01"] / m["m00"]  # ‚Üê L√çNEA 400 - Centro Y (subp√≠xel)
```

**Opci√≥n 3: Centroide Ponderado por Intensidad - L√≠nea 406-408**
```python
        if np.any(mask_region > 0):
            intensity = np.mean(gray[mask_region > 0])  # ‚Üê Intensidad promedio
            confidence = min(1.0, intensity / 200)      # ‚Üê Confianza por intensidad
```

**Matem√°tica de momentos:**
- m["m00"] = Œ£(p√≠xeles) = √Årea
- m["m10"] = Œ£(x √ó p√≠xel) = Momento en X
- m["m01"] = Œ£(y √ó p√≠xel) = Momento en Y
- **x = m["m10"] / m["m00"]** = Centroide ponderado en X
- **y = m["m01"] / m["m00"]** = Centroide ponderado en Y

---

### ‚úÖ FUSI√ìN DE DETECCIONES (L√≠nea 436-507)

**Funci√≥n:** `_merge_detections()`

**Algoritmo:**
```python
def _merge_detections(self, detections_list):
    # L√≠nea 448-450: Recolectar todas las detecciones de 4 m√©todos
    all_detections = []
    for detections in detections_list:
        for x, y, conf in detections:
            all_detections.append((x, y, conf))
    
    # L√≠nea 454: Ordenar por confianza (descendente)
    all_detections.sort(key=lambda d: d[2], reverse=True)
    
    # L√≠nea 457-480: Agrupar detecciones cercanas (< 20px)
    for i, (x1, y1, conf1) in enumerate(all_detections):
        if i in used:
            continue
        
        cluster = [(x1, y1, conf1)]
        for j, (x2, y2, conf2) in enumerate(all_detections):
            dist = np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)
            if dist < distance_threshold:  # L√≠nea 472 - 20px threshold
                cluster.append((x2, y2, conf2))
    
    # L√≠nea 481-492: Promediar cluster con pesos por confianza
    xs = np.array([c[0] for c in cluster])
    ys = np.array([c[1] for c in cluster])
    confs = np.array([c[2] for c in cluster])
    
    weights = confs / np.sum(confs)  # ‚Üê Pesos normalizados
    avg_x = np.sum(xs * weights)     # ‚Üê Promedio ponderado en X
    avg_y = np.sum(ys * weights)     # ‚Üê Promedio ponderado en Y
    avg_conf = np.mean(confs)
```

---

### ‚úÖ h) RASTREO TEMPORAL ROBUSTO (NO Kalman, S√ç Validaci√≥n)

**L√≠nea 510-549**
```python
def _assign_led_ids_robust(self, detections):
    """Asigna IDs de forma robusta, rechazando saltos grandes"""
    
    detections = sorted(detections, key=lambda d: d[0])  # Ordenar por X
    
    if len(detections) != self.expected_leds:
        return detections, list(range(len(detections)))
    
    if self.last_positions is None:
        self.last_positions = detections
        # ...
        return detections, ids
    
    # ‚Üê RASTREO ROBUSTO
    assignment = {}
    used = set()
    max_jump_dist = 150  # ‚Üê L√çNEA 530 - M√°xima distancia permitida
    
    for old_idx, (x_old, y_old, _) in enumerate(self.last_positions):
        best_new_idx = -1
        best_dist = float('inf')
        
        for new_idx, (x_new, y_new, _) in enumerate(detections):
            if new_idx in used:
                continue
            
            dist = np.sqrt((x_old - x_new) ** 2 + (y_old - y_new) ** 2)
            
            # ‚Üê L√çNEA 540 - RECHAZA SALTOS > 150px
            if dist > max_jump_dist:
                continue
            
            if dist < best_dist:
                best_dist = dist
                best_new_idx = new_idx
```

**Por qu√© 150px?**
- Video: 1280√ó720 p√≠xeles
- LEDs se mueven suavemente
- M√°ximo desplazamiento entre frames a 24 FPS ‚âà 150 p√≠xeles
- Si salta > 150px = Error de rastreo (rechazar)

---

### ‚úÖ M√âTODO PRINCIPAL: detect()

**L√≠nea 551-608**
```python
def detect(self, frame, visualization=False):
    """Detecta LEDs"""
    
    # L√≠nea 555: PREPROCESAMIENTO
    gray, filtered = self._preprocess(frame)
    
    # L√≠nea 557-560: EJECUTAR 4 M√âTODOS EN PARALELO
    det1 = self._detect_via_high_threshold(gray)       # M√©todo 1
    det2 = self._detect_via_adaptive_threshold(filtered) # M√©todo 2
    det3 = self._detect_via_hough(gray, filtered)      # M√©todo 3
    det4 = self._detect_via_contours(frame)            # M√©todo 4
    
    # L√≠nea 562: FUSI√ìN
    detections = self._merge_detections([det1, det2, det3, det4])
    
    # L√≠nea 565: RASTREO TEMPORAL
    detections, led_ids = self._assign_led_ids_robust(detections)
    
    # L√≠nea 567-570: CREAR ESTRUCTURA LEDDetection
    leds = [
        LEDDetection(x=x, y=y, confidence=conf, method="Combinado")
        for x, y, conf in detections
    ]
    
    success = len(leds) == self.expected_leds
    
    # L√≠nea 573-605: VISUALIZACI√ìN (opcional)
    viz_frame = None
    if visualization:
        # ... dibujar c√≠rculos, textos, etc ...
```

---

## üìç TABLA DE REFERENCIAS R√ÅPIDAS

| M√©todo | Funci√≥n | L√≠nea Inicio | L√≠nea Fin | Par√°metros |
|--------|---------|--------------|-----------|-----------|
| Escala Gris | `_preprocess()` | 280 | 301 | N/A |
| HSV | `_detect_via_contours()` | 390 | 430 | [0,0,200] a [180,100,255] |
| Gaussiana + Mediana | `_preprocess()` | 287 | 301 | kernel 5√ó5, œÉ=1.5 |
| Adaptive Threshold | `_detect_via_adaptive_threshold()` | 318 | 339 | neighborhood=31 |
| Blobs | `_detect_via_high_threshold()` | 303 | 337 | threshold=200, 30<area<300 |
| Hough Circles | `_detect_via_hough()` | 340 | 361 | radius 5-25, minDist=40 |
| Momentos | `_detect_via_contours()` | 396 | 401 | m00, m10, m01 |
| Fusi√≥n | `_merge_detections()` | 436 | 507 | distance<20px, weighted avg |
| Rastreo | `_assign_led_ids_robust()` | 510 | 549 | max_jump_dist=150px |
| **Principal** | **`detect()`** | **551** | **608** | **Coordina todo** |

---

## üîó FLUJO DE EJECUCI√ìN COMPLETO

```
main() [L√çNEA 880]
  ‚îú‚îÄ‚Üí VideoProcessor.process() [L√çNEA 774]
  ‚îÇ    ‚îî‚îÄ‚Üí cv2.VideoCapture(video)
  ‚îÇ
  ‚îú‚îÄ‚Üí Para cada frame:
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îî‚îÄ‚Üí detector.detect(frame, visualization=True) [L√çNEA 551]
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ‚Üí _preprocess(frame) [L√çNEA 555]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí cvtColor(BGR‚ÜíGRAY) [L√çNEA 283]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí GaussianBlur() [L√çNEA 294]
  ‚îÇ         ‚îÇ    ‚îî‚îÄ‚Üí medianBlur() [L√çNEA 300]
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ‚Üí det1 = _detect_via_high_threshold(gray) [L√çNEA 557]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí threshold(200) [L√çNEA 305]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí morphologyEx() [L√çNEA 310]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí connectedComponentsWithStats() [L√çNEA 315]
  ‚îÇ         ‚îÇ    ‚îî‚îÄ‚Üí calcular centroides [L√çNEA 320-337]
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ‚Üí det2 = _detect_via_adaptive_threshold(filtered) [L√çNEA 558]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí adaptiveThreshold() [L√çNEA 319]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí connectedComponentsWithStats() [L√çNEA 328]
  ‚îÇ         ‚îÇ    ‚îî‚îÄ‚Üí calcular centroides [L√çNEA 330-339]
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ‚Üí det3 = _detect_via_hough(gray, filtered) [L√çNEA 559]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí HoughCircles() [L√çNEA 340]
  ‚îÇ         ‚îÇ    ‚îî‚îÄ‚Üí extraer c√≠rculos [L√çNEA 350-361]
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ‚Üí det4 = _detect_via_contours(frame) [L√çNEA 560]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí cvtColor(BGR‚ÜíHSV) [L√çNEA 410]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí inRange(HSV) [L√çNEA 414]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí findContours() [L√çNEA 417]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí fitEllipse() o moments() [L√çNEA 394, 397]
  ‚îÇ         ‚îÇ    ‚îî‚îÄ‚Üí calcular centroides [L√çNEA 396-410]
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ‚Üí detections = _merge_detections([det1,det2,det3,det4]) [L√çNEA 562]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí Recolectar todas [L√çNEA 448]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí Ordenar por confianza [L√çNEA 454]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí Agrupar cercanas [L√çNEA 457-480]
  ‚îÇ         ‚îÇ    ‚îî‚îÄ‚Üí Promediar ponderado [L√çNEA 481-492]
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ‚Üí detections, led_ids = _assign_led_ids_robust(detections) [L√çNEA 565]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí Comparar con frame anterior [L√çNEA 522-549]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí Calcular distancias [L√çNEA 539]
  ‚îÇ         ‚îÇ    ‚îú‚îÄ‚Üí Rechazar si > 150px [L√çNEA 540]
  ‚îÇ         ‚îÇ    ‚îî‚îÄ‚Üí Asignar IDs consistentes [L√çNEA 542-548]
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îî‚îÄ‚Üí Visualizaci√≥n (opcional) [L√çNEA 573-605]
  ‚îÇ              ‚îú‚îÄ‚Üí Dibujar c√≠rculos [L√çNEA 596]
  ‚îÇ              ‚îî‚îÄ‚Üí Dibujar etiquetas [L√çNEA 597-600]
  ‚îÇ
  ‚îî‚îÄ‚Üí VideoProcessor.save_results() [L√çNEA 823]
       ‚îú‚îÄ‚Üí calculate_error_statistics() [L√çNEA 688]
       ‚îú‚îÄ‚Üí save_results() [L√çNEA 823]
       ‚îî‚îÄ‚Üí _generate_text_report() [L√çNEA 836]
```

---

## ‚ú® CONCLUSI√ìN

**Cada l√≠nea tiene un prop√≥sito espec√≠fico:**
- Preprocesamiento: L√≠neas 280-301
- 4 m√©todos paralelos: L√≠neas 303-430
- Fusi√≥n: L√≠neas 436-507
- Rastreo: L√≠neas 510-549
- Integraci√≥n: L√≠neas 551-608
- Procesamiento de video: L√≠neas 688-823
- Entrada: L√≠nea 880

**Total: 904 l√≠neas de c√≥digo altamente optimizado**

